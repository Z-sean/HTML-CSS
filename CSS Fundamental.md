# CSS 基础

## 什么是 CSS

- 级联样式表
- 我们使用 HTML 来描述页面内容，使用 CSS 来描述视觉风格，以及整个内容的基本布局
- CSS 由多个属性组成，这些属性允许我们进行格式化内容
- 学习方式是重复学习最重要的那些
- CSS 代码由选择器（渲染对象）和声明(渲染内容)组成
- CSS 规则：就是指选择器+声明块

## 三种类型/方式

- 内联 CSS
  - 在元素内部编写，只写 CSS
  - 通过属性 style 开始编写
  - 不建议使用，因为把 HTML 与 CSS 混合
- 内部 CSS
  - head 下子元素
  - 通过 style 元素开始
  - 好处是把 HTML 与 CSS 分开了
  - 缺点是，长时间的拓展会使得文件变得庞大
- 外联 CSS
  - 对于文件命名没有要求
  - 以 css 为后缀
  - 在 HTML 文件中，使用 link 元素(head 内部)进行与该外部文件的链接
    - link 元素的唯一目的就是连接 HTML 文件和 CSS 文件
    - 元素属性：href——指明地址，rel——用于说明文件与连接文件的关系常见有 stylesheet，icon,preload....

## 文本样式/属性

- 每个属性可以采用不同的类型，比如长度或者关键字
  - 比如 color：blue 就是关键字
  - font-size:20 就是长度
- 常设置属性值：
  - color ——颜色
  - font-size ——字号
  - font-family ——字体类型
  - text-transform ——文本转换：大小写类型转换
  - font-family ——字体风格：斜体？
  - line-height ——行高(常用在段落设置中)，没有单位，指的是字体大小的倍数
  - text-align ——文本对齐属性
  - font-weight ——字体粗细
- 关于长度类型的单位
  - 我们可以选择不同的单位
  - 最基础的是像素，px
- font-style
  - font-style: normal; /_ 正常 _/
  - font-style: italic; /_ 斜体 _/
  - font-style: oblique; /_ 倾斜体 _/
- font-family
  - font-family: serif; /_ 衬线字体 _/
  - font-family: sans-serif; /_ 无衬线字体 _/
  - font-family: monospace; /_ 等宽字体 _/
  - font-family: cursive; /_ 手写体 _/
  - font-family: fantasy; /_ 装饰体 _/
- 当我们设置 P 元素的大小样式时，包裹在其中的 strong/em/a 等元素样式也会改变
  - 这种机制叫做继承
- 具体样式针对于具体元素
  - 比如：针对 li 而不是 ul/ol
- cursor
  - 用于定义指针样式
    - cursor: default; /_ 默认箭头 _/
    - cursor: pointer; /_ 手型，表示可点击 _/
    - cursor: text; /_ 文本输入光标 _/
    - cursor: wait; /_ 等待状态 _/
    - cursor: move; /_ 移动十字箭头 _/

## 结合选择器

- 对于同样的声明条例，我们可以将相关的元素组合在一起进行样式渲染
- 对于选择器，使用逗号,分隔
- 类似于 OOP 中的抽象，将相似的样式设置集中子啊结合的选择器中
- 列表选择器
  - 就是简单的把选择器组合排列起来

### 后代选择器

- 通过"父级 子级 声明块"的排列方式
- 这种方式=选择了所有处于该父级元素下的该子级元素
- 该种方式也不是很稳健，因为在网页结构中，可能存在多个同级的同种结构，所以还是无法完全精准的选择
  - 可能还存在更多级别的结构，通过累加，能够选择到，但这加重了编码的复杂程度
- 为了精准的选择内容并进行渲染，我们通过添加多个结构来找到目的文本，本质上，我们是在 CSS 选择器中对 HTML 结构进行编码，过于繁杂是不好的

## id 选择器

- 为元素提供 id 属性，能够更好的找到目的元素
- 通过 id 选择进行渲染，更快的找到目的文本
- 格式"#id{声明块}"

## 类选择器

- 为元素提供 class 属性
  - 元素可被赋予多个类 使用空格区分即可
- 与 id 的区别是，元素 id 不允许重复
- class 允许我们多次重复使用同一个名字
- 所以 id 是单选框，class 是复选框
- 格式".类名{声明块}"
- 我们一般选择使用类而不是 id，因为类具有更好的兼容性，当我们构建复杂的页面时，减少修改次数
  - 使用类能够更好的为未来做准备

## 颜色使用

- RGB 模型是在编码过程中最常用的颜色使用方法
  - red green blue，为每种颜色提供 255 中调配值
  - 通过调整数值来完成不同颜色的配置
  - 两种表达方式
    - rgb(255,255,255)【rgb 函数表达】
      - 除此之外还有透明度，相关函数为 rgba(),第四个数值为透明度设置(0-1)
    - #00ffff【更多的使用选择：十六进制表达】【ff 表示十六进制的 255，所以每两位表示一个色值】
      - 简写：当两两重复时，比如 00ffff->0ff
      - 只有当需要透明度时，使用 rgba 函数
- 关于灰色的使用
  - 000 表示黑色
  - 255255255 表示白色
  - 在此之间，所有的三种数值相同的都是灰色
- 颜色选择器
  - 通过悬停在颜色表上，得到选择器
- 背景颜色属性
  - background-color
- 全局设置颜色
  - body 元素
  - background-color

## 边界属性

- border
- 是一个特殊的属性
- 接收多个声明
- border 允许我们接收多个数据来进行声明，也可以单独拿出来声明，一般我们集中声明
  - 粗细，颜色，样式
- 变体
  - border-top/bottom/left/right——用于设置单边

## 伪类

- 虚拟性：不是实际 DOM 元素
- 状态性：表示元素特定状态
- 位置性：表示元素特定位置
- 动态性：响应用户交互
- 简洁性：减少额外标签
- 举例使用场景
  - 当我们想渲染列表第一项的效果，我们通常会赋予相关元素特定的类名，然后进行声明
  - 使用伪类，我们不需要给这些元素特定的类名，根据特定的位置等直接声明
- 伪类元素会选择同一层级的元素，不会把嵌套在内部的元素算进去
- 特定位置
  - :first-child——首个
  - :last-child——最后一个
  - :nth-child(n)——第 n 个
    - 关于 n：
      - 常规数字
      - odd——奇数项
      - even——偶数项
- 使用注意事项：
  - 当使用组合类型的选择器，比如后代选择器：
    - article p:first-child 实际上，如果 p 不是 article 的第一个元素，那么不会工作【本意是选择 article 下的第一个 p】，必须满足 p 同时也是 article 的第一个子元素
      - 思考的过程是：首先看 p 的父元素，然后检查 P 是否是他父元素下的第一个子元素
      - 简化就是，链式的执行思考过程是，从右到左执行
- 完美的使用场景是:所有的子元素都相同

### 使用伪类设置超链接的样式

- 为超链接声明样式
  - a{....}
  - 实际上不推荐，这会渲染所有状态的超链接
  - 使用伪类，首先可以区分是否是具有实际意义的超链接
  - 其次对不同状态的链接，都可以进行渲染
    - 未访问 link
    - 已访问 visited
    - 鼠标悬停 hover
    - 点击状态 active
- 超链接样式说明
  - 之前的相关
  - 下划线 text-decoration ：none 表示没有 underline 表示下划线【样式选择 dotted....颜色】

## 开发者工具

- 使用方式
  - 右键菜单——检查
  - 键盘快捷键——F12
  - 菜单栏
- 使用
  - 左侧可看到元素
  - 右侧是样式编辑，需要点击对应的元素，才能展示对应的样式
  - 我们实际上可以直接在该工具上进行修改，然后根据选择框选择是否采用
  - 实际上不会影响我们的代码，只是用来查看效果
  - 在样式编辑器上栏中有":hov"表示伪类选择器，帮助我们伪装成不同状态下的效果

## CSS 理论——选择器冲突

- 指的是当一个元素被适用多个选择器的处理原则
- 实际上该元素所有的样式都适用
- 规则
  - 声明标记 !important
    |
  - 内联样式【就是直接使用在 HTML 元素中的 CSS 样式】
    |
  - 优先级 id 选择器>伪类选择器/类选择器>元素选择器
    |
  - 出现顺序—— 按照先后顺序
    |
  - 通用选择器
- 按照规则的顺序进行选择

## CSS 理论——继承

- 元素会继承来自父类元素的一些属性
- 当有同样的属性声明时，继承的属性会被覆盖
- CSS 中有可继承的属性与不可继承的属性

### 通用选择器

- "\*" 表示选择所有的元素
- 优先级最低
- 平等的选择所有元素并应用效果，与继承无关

## CSS 理论：CSS 盒子模型

- 什么是盒子模型？
  - 定义了元素如何显示在网页上以及大小
  - 每一个元素都被看作是矩形框，其中都可以有内容
- 关于盒子模型
  - 内容部分(content)：
    - 图像，文本等
    - 可以定义长宽
  - 边界部分(border)：元素周围的边框，但在技术上仍然在元素内部
  - 内填充部分(padding)：内容周围不可见的部分，仍然处于元素内部
    - 本质上是可以创作的空白空间，是内容与边界之间的空间，是元素最外层的部分
  - 外填充部分
    - 与之对应的还有一个填充区域(margin)：指的是盒子(元素)周围的空白区域，不在元素内部
    - 实际应用中，我们使用 margin 在元素之间创造空间
      - 例如，在两个特定的元素之间使用 margin 创建空间
  - 重申：填充是空白的空间，我们可以将其添加到任何元素的内部(padding)
  - 内容，边界，内填充部分是元素可见部分，然后，我们可以使用 margin，为了给元素周围添加一些空间
  - 填充区域(fill area)：
    - 指的是整个模型中的可见部分
    - 一般是背景图片或者背景颜色
    - 而文本，图片等只会出现在内容区域
- 关于盒子尺寸
  - 如果不指定宽或者高，那么盒子模型会暗示根据内容(就是盒子模型的默认行为)
  - 暗示的尺寸不是元素的最终尺寸，实际尺寸是边框+填充区+内容区
  - 高度同样如此
  - 我们可以指定特定的属性去修改尺寸
  - 但这里的修改没有实际意义，因为实际上的空间占据还需要计算 padding 和 border【后续我们会选择其他的模型来代替默认的模型】

## padding&margin

- 可以选择具体的填充区域
  - padding-left、bottom、right、top
  - 默认 padding 接收一个值表示全部，两个值：分别是上下和左右，四个值
- 设计 tip：一般列表项目中，我们只想元素之间有空间而不是元素末尾有空间，所以我们将最后一个列表
  - 设置方式：使用通用选择器
  - 这是开始一个项目之前做的第一件事
- 使用建议：元素之间使用 margin，元素内部：就是去内容和边框之间的使用 padding
- 边距塌陷
  - 当两个填充空间占据同一块区域时，页面上实际只有一个可见，通常是两者较大的一个
- 常用 margin 的边缘与底部来创建元素之间的空间

## width&height

- 在默认情况下，设置的 width 和 height 不是真实的尺寸，我们需要注意
- 之前我们设置 padding 会达到视觉上的垂直居中(使用了相同的填充)，当我们设置高度等属性后，居中会被打破，因为填充相同，但高度出现了偏差
- 针对图片的调整
  - 默认情况下，图片保持原始尺寸
  - 设置尺寸属性后，可以调整 width/height，任意一个为 auto，自动变化，默认情况下，也会按照原始比例进行调整，但显式说明代码逻辑更清晰
  - 使用比例而不是像素，比例通常是指的是父容器的

## 页面居中

- 解决方法是将页面放在一个容器盒子中
  - body->div:container
- 1.指定一个宽度，限制内容在容器中
- 2.指定填充空间 margin【因为目的是让 div 盒子在 body 中居中，所以设置 margin】
  - margin-left&right:auto——自动计算，获得居中效果
  - 对于 padding，因为块级元素默认占据整个容器内部
    - 同时，padding 没有 auto 选项

## 挑战收获：

- 工作开始第一步
  - 设置通用选择器：margin/padding 为 0——便于后续的布局设置
  - 布局设置：
    - 指定固定宽度
    - 设置 margin，左右为自动设置
- a 元素在默认情况下不能设置 margin 的上下，只能设置左右

## CSS 理论：不同的盒子模型

- 内嵌框/内联盒子(inline box):这种盒子只占用他们内容所需要的空间，
  - 在行内排列
  - 不设置宽高
  - 上下 margin 不生效
  - span、a、em、i
  ***
  - 只占用内容所需要的空间，宽度由内容决定
  - 不会造成换行，多个内联元素会在同一行排列
  - 不能设置 width 和 height，尺寸由内容决定
  - margin 和 padding 只在水平方向生效，左右可以设置，上下不会生效
- 块级框/块级元素(block box):占据他们所能够占据的全部空间，他们会在他们之后创建换行符，就是说他们不能并肩作战【与行内框的区别】
  - 独占一行
  - 可设置宽高
  - margin/padding 完全生效
  ***
  - 元素以块的形式呈现，有明显的矩形区域
  - 默认占满父级容器的 100%宽度，不管内容多少都会占满整行，通过 width 改变
  - 元素默认垂直堆叠，每个元素独占一行，自上而下依次改变
  - 完全支持盒模型的全部属性，margin/padding/border 都可以设置，width 和 height 都生效
  ***
- 对内联元素设置 padding，那背景色会拓展到 padding 区，但并不会推开周围的其他元素(就是产生移动)
- 通过设置属性 display:block 将内联元素设置为块级元素的显示方式
- 一般不设置固定的高度，而是让元素自动适应内容高度(auto)
  - 这样，当子元素需要更多的垂直高度时，可以更好的适应(如果使用固定值，那么当空间不够时，子元素的内容会溢出到其他区域或者溢出边界之外)
- display：block/inline——可分别用于设置为块级元素或者是行级元素

---

- 内联块元素

  - display:inline-block
  - 集中了两者的优势
  - 在外部，可以和其他元素并排显示，在内部，可以设置宽高，padding，margin 等属性
  - 只占用内容所需要的空间，宽度由内容决定
  - 不会造成换行，出费空间不够
  - 完整的适用于盒模型
  - img 元素实际上就是一个内联块元素

  ***

- 总结：
  - 默认的盒模型通常是合理的
  - 需要改变的场景：
    - 把内联变成块级：
      - 让一个小元素占据整行
      - 想给内联元素设置宽高
    - 把块级变成内联
      - 不希望强制换行
      - 不希望占据整个宽度
      - 希望元素可以并排展示
    - inline-block 通常是更灵活的选项

## CSS 理论：绝对定位

- 正常流程
  - 默认的定位方式
  - static
  - 元素处于 in flow
  - 元素按照 HTML 代码的顺序排列
  - 不会脱离文档流
- 相对定位
  - relative
  - 保持在正常流中
  - 使用 top，bottom，right，left 进行相对于原来位置的移动，**无论元素移动在哪里，都会保留原始位置(占着初始位置)，但在视觉可能会出现侵占的现象**
    - 想象一下就像是：
    - 先按正常文档流排好位置
    - 然后把相对定位的元素"复制"一份
    - 这个"复制"的元素移动到新位置
    - 原来的位置保持空着
    - 其他元素的位置不变
  - 不会影响其他元素
  - 最重要**为绝对定位元素创建上下文**
    - 这就是为什么要保留原始位置，绝对位置就是按照原始位置来定位的，同时也不影响相对位置元素本身的移动
- 绝对定位
  - absolute
  - 脱离正常流程(in flow)
  - 不影响其他元素位置，视觉上会出现重叠
  - 使用 top，bottom，left，right 进行定位
  - 相对于最近的定位祖先元素进行定位
    - 如果有已定位的祖先元素(不是 static)，就相对于最近的祖先进行定位
    - 如果没有，就相对于文档根元素进行定位
    - 如果特殊情况下，html 元素也没有定位，就相对于视口定位
- 固定定位
  - fixed
  - 脱离正常流
  - 相对与视口进行定位
  - 不会随着页面滚动移动

---

- 实践：

  - 绝对定位：将元素“定死”在一个位置，看着像漂浮在整个页面之上
  - emoji：win+.
  - 设置：position:absolute
  - 当没有设置定位的祖先元素时，相对于文档根元素为定位，会随着页面滚动而滚动

  ***

  总结：

  - 相对于祖先元素：说明是元素与祖先元素之间的位置关系是确定的
  - 相对与 html，说明元素在 html 文档上的位置是确定的
  - 相对于视口，说明元素的位置在当前可见窗口的位置是确定的
  - 关于随着滚动条移动的问题：
    - 相对于 html，就相当于你在地图上标记一点，你移动地图，点的位置会跟随你标记处的移动而移动
    - 相对于视口，相对于你标记的不是地点，而是位置，无论底层地图怎么移动，你这个点是扎在了你的“屏幕上”
  - 同时，绝对定位元素的位置只与相对定位元素的位置有关，与他在 HTML 代码结构中的位置无关
  - 绝对定位元素寻找祖先元素的顺序是按照 DOM 树的顺序向上查找的
  - 建议：不要使用定位属性来构建复杂的布局，使用这种属性构建像按钮这样的小东西/单个元素

  ***

  我的疑问：
  在设置绝对定位的时候，按钮直接出现在了视口范围内的相对位置上，而按照规定应该是出现在 html 的相对位置上，但按钮会随着页面移动而移动，又符合相对 HTML 定位的特征
  原因：默认情况下，我们不设置 HTML 文档的高度，那么即使 HTML 文档的内容超出了视口范围，HTML 文档也会默默的将高度与视口匹配，即使部分内容需要由滚动才能看见，所以在定位按钮时，他出现在了视口的相对位置，因为他认为这就是 HTML 的相对位置！

  ## 伪元素

- 指的是 HTML 中不存在的元素，但仍然可以在 CSS 中选择和设置样式
  - 例如开头的首字母，段落的第一行....
- 使用::来表示
  - 例如：::first-letter ——首字母
  - ::first-line ——首行

## 兄弟选择器

- 需要是同一个父级元素下
- 相邻兄弟选择器：紧随其后的元素
- 使用+指定兄弟选择器的作用范围
  - 如：h3+p ——表示 h3 元素之后紧邻的 p 元素
- 最常见的伪元素：after/before
- after
  - 第一个元素是强制性的：content ——表示文本内容
  - 其余的属性设置与普通元素一致
  - 关于位置的摆放：通过+/-来调整上下左右
- before
  - 与 after 效果一致
  - 不同的是 before 会成为第一个子元素，而 after 会是最后一个
- 由于使用了绝对定位 ，所以看起来不会有差别(在相同的设置中)

## 学会做一个程序员

- 当我们忘记如何制作一个效果
  - CSS【因为是与 css 相关的】 属性 功能【比如说把鼠标光标加在按钮上】
  - 基本上可以在 stack overflow 上找到解决方案
  - CSS-Trick
- 关于 CSS 属性学习
  - mdn CSS + 属性

## 技能：debug 与问问题

- 没有关闭某个元素
  - 查找格式变化的地方，在对应的 HTML 文档寻找
- 对于内容变化不明显的错误，使用 HTML 验证器验证
  - HTML validator
- 元素使用错误
  - 差异检测器 diffchecker——检查标准代码与自己代码的区别
- 关于多选择器优先级问题：
  - 如果一个选择器比另一个更复杂，那么实际上会使用更复杂的那一个
  - 选择器应该保持低特异性【够简单，够直接】
- 属性的拼写错误
  - 通过检查浏览器开发者工具，检查出现差错的地方，会标注那一个属性出现的错误
- 使用浏览器根据
  - 例如，在选择字体大小属性，利用上下键调整大小，观察最佳的选择
  - 或者 shift+上下键会以十倍的倍率缩放
- 若 CSS 样式不起效，首先检查是否链接到了正确的 CSS 文件
